package ru.vitte.online.helpdesk.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.hibernate.Hibernate;
import org.mapstruct.factory.Mappers;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import ru.vitte.online.helpdesk.dto.IncomingIssueDto;
import ru.vitte.online.helpdesk.dto.IssueDto;
import ru.vitte.online.helpdesk.entity.IssueEntity;
import ru.vitte.online.helpdesk.entity.PersonEntity;
import ru.vitte.online.helpdesk.entity.enums.Role;
import ru.vitte.online.helpdesk.entity.enums.Status;
import ru.vitte.online.helpdesk.mapper.IssueMapper;
import ru.vitte.online.helpdesk.mq.NewIssuePublisher;
import ru.vitte.online.helpdesk.mq.NotificationPublisher;
import ru.vitte.online.helpdesk.repository.IssueRepository;
import ru.vitte.online.helpdesk.repository.PersonRepository;
import ru.vitte.online.helpdesk.service.api.IssueService;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class IssueServiceImpl implements IssueService {

    private final IssueRepository issueRepository;
    private final PersonRepository personRepository;
    private final NewIssuePublisher newIssuePublisher;
    private final NotificationPublisher notificationPublisher;
    private final IssueMapper issueMapper = Mappers.getMapper(IssueMapper.class);

    @Override
    public IssueDto createIssue(String email, IncomingIssueDto issueDto) {
        IssueEntity issueEntity = issueMapper.mapIssue(issueDto);

        PersonEntity user = personRepository.findByEmail(email).orElseThrow(() -> new RuntimeException("User not found"));
        issueEntity.setUser(user);
        issueEntity.setStatus(Status.NEW);

        IssueEntity savedIssue = issueRepository.save(issueEntity);
        var savedIssueDto = issueMapper.mapIssue(savedIssue);
        newIssuePublisher.sendToTopic(savedIssueDto);
        return savedIssueDto;
    }

    @Override
    public IssueDto getIssueById(String email, long issueId, boolean isEmployee) {
        IssueEntity issue = issueRepository.findById(issueId).orElseThrow(() -> new RuntimeException("Issue not found"));

        if (!isEmployee) {
            if (!issue.getUser().getEmail().equals(email)) {
                throw new RuntimeException("Access denied");
            }
        }

        return issueMapper.mapIssue(issue);
    }

    @Override
    public List<IssueDto> getAllIssues(String email, boolean isEmployee) {
        List<IssueEntity> issues = new ArrayList<>();

        if (isEmployee) {
            issues.addAll(issueRepository.findByStatus(Status.NEW));
            issues.addAll(issueRepository.findByStatus(Status.IN_PROGRESS));
            issues.addAll(issueRepository.findByStatus(Status.AUTOGENERATED));
            issues.addAll(issueRepository.findByStatus(Status.CLOSED));
        } else {
            PersonEntity user = personRepository.findByEmail(email).orElseThrow(() -> new RuntimeException("User not found"));
            issues = issueRepository.findByUser(user);
        }

        return issues.stream()
                .map(issueMapper::mapIssue)
                .collect(Collectors.toList());
    }

    @Override
    public IssueDto updateIssue(String email, long issueId, boolean isEmployee, IncomingIssueDto issueDto) {
        PersonEntity user = personRepository.findByEmail(email).orElseThrow(() -> new RuntimeException("User not found"));
        IssueEntity issue = issueRepository.findById(issueId).orElseThrow(() -> new RuntimeException("Issue not found"));

        if (isEmployee) {
            issue.setEmployee(user);
        } else if (issue.getUser().getEmail().equals(email)) {
        } else {
            throw new RuntimeException("Access denied");
        }

        issue.setStatus(Status.IN_PROGRESS);
        issue.getIssueComment().add(issueMapper.mapIssueComment(issueDto.getIssueComment()));

        IssueEntity updatedIssue = issueRepository.save(issue);
        this.notificationPublisher.sendToTopic(issueMapper.mapToNotificationDto(updatedIssue));
        return issueMapper.mapIssue(updatedIssue);
    }

    @Override
    public void deleteIssue(String email, long issueId) {
        IssueEntity issue = issueRepository.findById(issueId).orElseThrow(() -> new RuntimeException("Issue not found"));

        if (issue.getUser().getEmail().equals(email)) {
            issueRepository.delete(issue);
        } else {
            throw new RuntimeException("Access denied");
        }
    }

    @Override
    public void closeIssue(String email, long issueId, boolean isEmployee) {
        PersonEntity user = personRepository.findByEmail(email).orElseThrow(() -> new RuntimeException("User not found"));
        IssueEntity issue = issueRepository.findById(issueId).orElseThrow(() -> new RuntimeException("Issue not found"));
        Role userRole = user.getRole();
        if (issue.getUser().getEmail().equals(email) || isEmployee || userRole == Role.ADMIN) {
            issue.setStatus(Status.CLOSED);
            issueRepository.save(issue);
        } else {
            throw new RuntimeException("Access denied");
        }
    }

    @Transactional
    @Override
    public void updateIssueWithAutogeneratedAnswer(IncomingIssueDto message) {
        IssueEntity issue = issueRepository.findById(message.getId()).orElseThrow(() -> new RuntimeException("Issue not found"));
        Hibernate.initialize(issue.getIssueComment());
        if (issue.getStatus() == Status.NEW) {
            issue.setStatus(Status.AUTOGENERATED);
            issue.getIssueComment().add(issueMapper.mapIssueComment(message.getIssueComment()));
            issueRepository.save(issue);
            log.error("I BELIEVE !!!!!!!!!!!");
        }
    }
}
